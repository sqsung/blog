---
title: "Using ISR and On-Demand Revalidation to Improve the Performance of My Next.js Project"
summary: "I think I found the perfect use case for ISR and on-demand revalidation."
tags: ["Frontend", "Nextjs", "ISR", "On-Demand-Revalidation"]
createdAt: "2025-06-30"
isPublished: false
---

## 1. My Project

Over the past few months, I've dedicated much of my free time building a web service where young Korean couples can come create/share digital invitations to their weddings.

As with any side project, I learned a lot throughout the process.
But one of the most valuable takeaway for me was gaining a deeper understanding of how ISR (Incremental Static Regeneration) and on-demand revalidation work in a real-world scenario.

To explain how I improved my service's performance by using these techniques,
let's first explore some key usage patterns I observed during the service's beta launch.

### 1-1. Key Usage Patterns

After completing the initial version, I granted free access to a handful of users.
My original goal was simply to confirm everything worked as intended before launching a paid version.
But through this test run, I noticed some interesting user behaviors:

1. Each user shared their invitation with approximately 300 guests on average
2. Sharing typically occurred in bulks. This means users usually shared their invitations to dozens of guests at once
3. Guests usually checked the invitation twice: once immediately after receiving it, and again on the day of the wedding to confirm the event's time and location

### 1-2. Implications

Let's take an imaginary user, User A, as an example.
Eager to have a well-attended wedding, User A invites a total of 500 guests over a span of five consecutive days.
And to simplify the process, he shares his invitation to exactly 100 guests each day.

Based on usage patterns, User A's invitation page would likely experience six distinct traffic spikes.
Over the five days when User A is sending out his invitation, the page would likely receive 100 requests per day.
Then traffic will peak on the wedding day as around 500 guests revisit the page to confirm event details.

If the invitation page was rendered using SSR or CSR, each of these requests would trigger a unique call to fetch the invitation data.
This would put an excessive load on my little precious t3-micro EC2 instance server.
And since invitation data rarely changes, this excessive load is by all means avoidable.

### 1-3. Next.js Version

For context, I used Next.js version 14.2.3 (page router) to build my project.
Keep in mind that things discussed within this post may not be applicable to future versions of Next.js.

```JSON
"next": "14.2.3",
```

## 2. ISR vs. SSG/SSR

Next.js offers the following server-side rendering strategies:

1. Static Site Generation (SSG)
2. Server-Side Rendering (SSR)
3. Incremental Static Regeneration (ISR)

SSG builds pages during deployment and serves them as static HTML.
This keeps pages fast and efficient, but any content updates require a full rebuild and redeployment.
As a result, SSG is best suited for pages where the data changes infrequently and real-time updates are not critical to the user experience.

On the other hand, SSR renders pages on every new request.
It's ideal for pages with frequently changing data that needs to be up to date on every load.
But because a new request triggers a new render, SSR requires more server resources and is consequently slower to load.

ISR offers a middle ground between SSG and SSR.
With ISR, pages are:

- Built at build time and served statically for fast performance
- Regenerated in the background after a configured interval without a full site rebuild

It's performant, but somewhat flexible enough to keep contents up to date.

## 3. Implementing ISR

Implementing ISR in a page router Next.js project is quite straightforward:
you simply specify a `revalidate` value in your `getStaticProps` function.

I implemented ISR on my project's invitation page with a 24 hour revalidation interval.
Here's a simplified version of my actual implementation as an example.

```tsx
// /src/pages/invitation/[alias]/index.tsx

export default function InvitationPage({ invitation }: InvitationPageProps) {
  return <Invitation invitation={invitation} />;
}

export const getStaticProps: GetStaticProps = async (context) => {
  const alias = context.params.alias.toString() || "";

  try {
    const invitation = await getInvitationByAlias(alias);

    return {
      props: {
        invitation,
      },
      revalidate: ONE_DAY,
    };
  } catch (error) {
    return {
      props: {
        invitation: null,
      },
      revalidate: 1,
    };
  }
};

export const getStaticPaths: GetStaticPaths = async () => {
  return {
    paths: [],
    fallback: true,
  };
};
```

### 3-1. ISR with Dynamic Routes

One important detail to note is that the invitation page uses a dynamic slug in its path ('/invitation/[alias]').
Since users customize their invitation aliases, it's impossible to know ahead of build time what every alias will turn out to be.

I mentioned earlier that ISR pages are generated at build time and regularly revalidated.
But in cases like this where the path is dynamic, we can use the `getStaticPaths` function with an empty `paths` array to opt Next.js out of pre-building any pages.
Instead, Next.js will generate each page during runtime when they are first requested for.

### 3-2. Why Revalidate = 1?

When an error occurs while fetching the invitation data,
the `getStaticProps` function throws and falls into the catch block.
In many cases, errors are not permanent.
Therefore, it's best not to cache error responses for too long.

That's why in the catch block, I set the `revalidate` property to 1;
this tells Next.js to mark the page as stale after just one second.
By doing so, I could keep the page within the ISR flow while giving users the ability to retry getting the correct data.

Setting the `revalidate` property to 0 does not work.
Doing so would disable ISR and make the page behave like a statically generated page.
This means the error would be cached indefinitely and the page wouldn't update until the next site deployment.

### 3-3. ISR Effects

Implmenting ISR had two major benefits for my project:

1. Lower server load as traffic spikes no longer triggered a flood of database queries
2. Better client performance as most visitors were served static pages

To better visualize, let's let's assume a total of 150 guests requested for an invitation with the alias of 'cool-invy' over a course of three days.

- <strong>Day 1:</strong> 50 guests
- <strong>Day 2:</strong> 0 guests
- <strong>Day 3:</strong> 100 guests

Here is how ISR would work in this scenario:

- The first visitor of Day 1 triggers the initial generation of `/invitation/cool-invy`
- The next 49 guests of Day 1 receive the cached version of the page
- Although the revalidation period expires on Day 2, regeneration does not occur because no one visits the page
- The first visitor of Day 3 triggers the second generation of the page
- The remaining 99 guests on Day 3 get the newly cached version

This means for three days, my backend server had to only handle 2 requests while the website served 150 visitors.
It also means only 2 of the 150 visitors had to experience a slight delay in page load time, while the remaining 148 visitors were able to see the page near instantly.

## 4. On-Demand Revalidation

Let's go back to the example of our imaginary user, User A.
If User A realizes on the morning of his wedding day that there is a mistake in his wedding venue address,
he would probably like his updates to bypass the 24 hour interval and show up immediately.
Because otherwise, his guests would arrive at the wrong venue and his dream of having a well-attended wedding would be ruined.

On-demand revalidation is the perfect solution for situation like this.
It's a feature that allows you, or your users, to manually revalidate a page without having to wait for the revalidation interval to expire.

## 5. Implementing On-Demand Revalidation

To implement on-demand revalidation in a Next.js page router project, you first need to create a new API route inside the `/pages/api` directory.
Then whenever you want to manually revalidate, you can call the API route to tell the Next.js server to revalidate the page.

```typescript
async function revalidateInvitation(req: NextApiRequest, res: NextApiResponse) {
  const { alias, secret } = req.body;

  if (!alias || !secret) {
    // ...handle bad request error
  }

  if (secret !== process.env.REVALIDATE_SECRET) {
    // ...handle unauthorized error
  }

  try {
    await res.revalidate(`/invitation/${alias}`);

    return res.status(200).json({
      isRevalidated: true,
    });
  } catch (error) {
    // ...handle revalidation error
  }
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  if (req.method === "POST") {
    return await revalidateInvitation(req, res);
  }

  res.setHeader("Allow", ["POST"]);
  res.status(405).end("Method Not Allowed");
}
```

### 5-1. Security Concerns

For obvious reasons, granting public access to the revalidation API route is not a good idea.
If there isn't a security validation layer, anyone with the URL can revalidate the page without any restrictions.

In my project, I added an environment variable called `REVALIDATE_SECRET` to both the Next.js and backend server.
Before actually revalidating the page, I check if the `REVALIDATE_SECRET` value matches.

Then when users update their invitations, I have my API server make the POST request to my Next.js server to revalidate the invitation page of the given alias.

<div className="relative aspect-square w-full">
  <Image
    src="/assets/on-demand-revalidation-flow.png"
    alt="Diagram of on-demand revalidation"
    fill
    objectFit="contain"
    className="invert dark:invert-0"
  />
</div>
