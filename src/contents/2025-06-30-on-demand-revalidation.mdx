---
title: "How I Optimized My Next.js App with ISR and On-Demand Revalidation"
summary: "Learn how I used ISR and on-demand revalidation to serve dynamic content at scale, keeping server load low and performance high."
tags: ["Frontend", "Nextjs", "ISR", "On-Demand-Revalidation"]
createdAt: "2025-06-30"
isPublished: true
---

## 1. My Project

Over the past few months, I've dedicated much of my free time building a web service where young Korean couples can come create/share digital invitations to their weddings.

As with any side project, I learned a lot throughout the process.
But one of the most valuable takeaway for me was gaining a deeper understanding of how ISR (Incremental Static Regeneration) and on-demand revalidation work in a real-world scenario.

To explain how I improved my service's performance by using these techniques,
let's first explore some key usage patterns I observed during the service's beta launch.

### 1-1. Key Usage Patterns

After completing the initial version, I granted free access to a handful of users.
My original goal was simply to confirm everything worked as intended before launching a paid version.
But through this test run, I noticed some interesting user behaviors:

1. Each user shared their invitation with approximately 300 guests on average
2. Sharing typically occurred in bulks. This means users usually shared their invitations to dozens of guests at once
3. Guests usually checked the invitation twice: once immediately after receiving it, and again on the day of the wedding to confirm the event's time and location

### 1-2. Implications

Let's take an imaginary user, User A, as an example.
Eager to have a well-attended wedding, User A invites a total of 500 guests over a span of five consecutive days.
And to simplify the process, he shares his invitation to exactly 100 guests each day.

Based on usage patterns, User A's invitation page would likely experience six distinct traffic spikes.
Over the five days when User A is sending out his invitation, the page would likely receive 100 requests per day.
Then traffic will peak on the wedding day as around 500 guests revisit the page to confirm event details.

If the invitation page was rendered using SSR or CSR, each of these requests would trigger a unique call to fetch the invitation data.
This would put an excessive load on my little precious t3-micro EC2 instance server.
And since invitation data rarely changes, this excessive load is by all means avoidable.

### 1-3. Next.js Version

For context, I used Next.js version 14.2.3 (pages router) to build my project.
Keep in mind that things discussed within this post may not be applicable to future versions of Next.js.

```JSON
"next": "14.2.3",
```

## 2. ISR vs. SSG/SSR

Next.js offers the following server-side rendering strategies:

1. Static Site Generation (SSG)
2. Server-Side Rendering (SSR)
3. Incremental Static Regeneration (ISR)

SSG builds pages during deployment and serves them as static HTML.
This keeps pages fast and efficient, but any content updates require a full rebuild and redeployment.
As a result, SSG is best suited for pages where the data changes infrequently and real-time updates are not critical to the user experience.

On the other hand, SSR renders pages on every new request.
It's ideal for pages with frequently changing data that needs to be up to date on every load.
But because a new request triggers a new render, SSR requires more server resources and is consequently slower to load.

ISR offers a middle ground between SSG and SSR.
With ISR, pages are:

- Built at build time and served statically for fast performance
- Regenerated in the background after a configured interval without a full site rebuild

It's performant, but somewhat flexible enough to keep contents up to date.

## 3. Implementing ISR

Implementing ISR in a pages router Next.js project is quite straightforward:
you simply specify a `revalidate` value in your `getStaticProps` function.

I implemented ISR on my project's invitation page with a 24 hour revalidation interval.
Here's a simplified version of my actual implementation as an example.

```tsx
// /src/pages/invitation/[alias]/index.tsx

export default function InvitationPage({ invitation }: InvitationPageProps) {
  return <Invitation invitation={invitation} />;
}

export const getStaticProps: GetStaticProps = async (context) => {
  const alias = context.params.alias.toString() || "";

  try {
    const invitation = await getInvitationByAlias(alias);

    return {
      props: {
        invitation,
      },
      revalidate: ONE_DAY,
    };
  } catch (error) {
    return {
      props: {
        invitation: null,
      },
      revalidate: 1,
    };
  }
};

export const getStaticPaths: GetStaticPaths = async () => {
  return {
    paths: [],
    fallback: true,
  };
};
```

### 3-1. ISR with Dynamic Routes

One important detail to note is that the invitation page uses a dynamic slug in its path ('/invitation/[alias]').
Since users customize their invitation aliases, it's impossible to know ahead of build time what every alias will turn out to be.

I mentioned earlier that ISR pages are generated at build time and regularly revalidated.
But in cases like this where the path is dynamic, we can use the `getStaticPaths` function with an empty `paths` array to opt Next.js out of pre-building any pages.
Instead, Next.js will generate each page during runtime when they are first requested for.

### 3-2. Why Revalidate = 1?

When an error occurs while fetching the invitation data,
the `getStaticProps` function throws and falls into the catch block.
In many cases, errors are not permanent.
Therefore, it's best not to cache error responses for too long.

That's why in the catch block, I set the `revalidate` property to 1;
this tells Next.js to mark the page as stale after just one second.
By doing so, I could keep the page within the ISR flow while giving users the ability to retry getting the correct data.

Setting the `revalidate` property to 0 does not work.
Doing so would disable ISR and make the page behave like a statically generated page.
This means the error would be cached indefinitely and the page wouldn't update until the next site deployment.

## 4. On-Demand Revalidation

Letâ€™s return to the example of our imaginary user, User A.
Suppose User A realizes he's listed the wrong venue address on the morning of his wedding day.
He would want the fix to be reflected immediately without having to wait 24 hours for the next scheduled revalidation.

On-demand revalidation is a perfect solution for situations like this.
It allows you to manually trigger a revalidation, bypassing the regular interval and ensuring that updates are reflected right away.

## 5. Implementing On-Demand Revalidation

To implement on-demand revalidation in a Next.js pages router project:

1. Create a new API route inside the `/pages/api` directory
2. Inside this route, call `res.revalidate()` with the path of the page you want to update
3. Trigger this API route when a manual revalidation is required

```typescript
async function revalidateInvitation(req: NextApiRequest, res: NextApiResponse) {
  const { alias, secret } = req.body;

  if (!alias || !secret) {
    // ...handle bad request error
  }

  if (secret !== process.env.REVALIDATE_SECRET) {
    // ...handle unauthorized error
  }

  try {
    await res.revalidate(`/invitation/${alias}`);

    return res.status(200).json({
      isRevalidated: true,
    });
  } catch (error) {
    // ...handle revalidation error
  }
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  if (req.method === "POST") {
    return await revalidateInvitation(req, res);
  }

  res.setHeader("Allow", ["POST"]);
  res.status(405).end("Method Not Allowed");
}
```

### 5-1. Security Concerns

For obvious reasons, exposing your revalidation API route to the public is risky.
Without a proper security check in place, anyone who knows the URL could revalidate your pages and consume unnecessary server resources.

To prevent this, I trigger my API route via my backend server only.
In addition, I added a simple security layer in my API route.
The revalidation process goes as follows:

1. Users update their invitation, sending a PATCH request to the backend server
2. Server updates the database and makes a POST request to the API route with the `REVALIDATE_SECRET` attached to the request body
3. Next.js server checks if the attached secret matches its version of `REVALIDATE_SECRET`
4. If the two secrets match, Next.js proceeds to revalidate the /invitation/[alias] page

<div className="relative aspect-square w-full">
  <Image
    src="/assets/on-demand-revalidation-flow.png"
    alt="Diagram of on-demand revalidation"
    fill
    objectFit="contain"
    className="invert dark:invert-0"
  />
</div>

## 6. Results

Implmenting ISR had two major benefits for my project:

1. Lower server load as traffic spikes no longer triggered a flood of database queries
2. Better client performance as most visitors were served static pages

To better visualize, let's let's assume a total of 150 guests requested for an invitation with the alias of 'cool-invy' over a course of three days.

- <strong>Day 1:</strong> 50 guests
- <strong>Day 2:</strong> 0 guests
- <strong>Day 3:</strong> 100 guests

Here is how ISR would work in this scenario:

- The first visitor of Day 1 triggers the initial generation of `/invitation/cool-invy`
- The next 49 guests of Day 1 receive the cached version of the page
- Although the revalidation period expires on Day 2, regeneration does not occur because no one visits the page
- The first visitor of Day 3 triggers the second generation of the page
- The remaining 99 guests on Day 3 get the newly cached version

This means for three days, my backend server had to only handle 2 requests while the website served 150 visitors.
It also means only 2 of the 150 visitors had to experience a slight delay in page load time, while the remaining 148 visitors were able to see the page near instantly.

And thanks to on-demand revalidation, I was able to enjoy the benefits of ISR without compromising user experience.
Without it, I likely wouldnâ€™t have adopted ISR at all â€” or at the very least wouldnâ€™t have been so bold in setting a long revalidation interval.

If your project has similar requirements as mine,
or if youâ€™re simply trying to better understand how ISR and on-demand revalidation work,
I highly recommend implementing them yourself.
You may be surprised by how much performance and flexibility they can offer.
