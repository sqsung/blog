---
title: "How I Optimized My Next.js App with ISR and On-Demand Revalidation"
summary: "Learn how I used ISR and on-demand revalidation to serve dynamic content at scale, keeping server load low and performance high."
tags: ["Frontend", "Nextjs", "ISR", "On-Demand-Revalidation"]
createdAt: "2025-06-30"
isPublished: true
---

## 1. My Project

Over recent months, I've spent a lot of my free time working on a solo project.
It's a web service targeted for young Korean couples, where they can come create and share digital wedding invitations.

After finishing the initial version, I granted free access to a handful of friends and acquaintances to test the service.
During this process, I noticed some couple interesting user behaviors:

1. On average, each user shared their invitation with approximately 300 guests
2. Users typically shared in bulks, up to dozens of guests at once
3. Once sharing began, users rarely made updates to their invitation
4. Most guests checked the invitation twice: once after receiving it, and again on the wedding day to confirm the event's time and location

Noticing these patterns, I realized implementing Incremental Static Regeneration (ISR) and On-Demand Revalidation would be a good way to optimize service performance.

FYI, I used Next.js Pages Router v14.2.3 to build my project.
Keep in mind that things discussed within this post may not be applicable to other versions of Next.js.

```JSON
"next": "14.2.3",
```

## 2. Identifying the Problem

To identify the problem, let's consider an imaginary user called User A.

Eager to have a well-attended wedding, User A invites a total of 500 guests.
Over a span of five consecutive days, he diligently invites 100 guests each day.

Based on our understanding of user behavior, we can expect six traffic spikes on User A’s invitation page:

1. 100 requests per day during the five-day invitation period
2. 500 requests on the wedding day as guests revisit the page to confirm event details

Before any optimization, the invitation page was rendered using Server-Side Rendering (SSR).
This meant that each of the 600 requests triggered a fresh API call and a newly rendered invitation page.

As a result, users had to wait longer due to network latency and rendering time.
And my backend server, deployed on a modest t3.micro EC2 instance, was put under an unnecessary strain.
Considering that invitation data rarely changes, this level of server load was entirely avoidable.

To understand how ISR can solve this problem, let's first understand what ISR is and how it compares to other server-side rendering strategies.

## 3. ISR vs. SSG/SSR

Next.js offers the following server-side rendering strategies:

1. Static Site Generation (SSG)
2. Server-Side Rendering (SSR)
3. Incremental Static Regeneration (ISR)

SSG builds pages during deployment and serves them as static HTML.
This keeps pages fast and efficient, but any content updates require a full rebuild and redeployment.
As a result, SSG is best suited for pages where the data changes infrequently and real-time updates are not critical to the user experience.

On the other hand, SSR renders pages on every new request.
It's ideal for pages with frequently changing data that needs to be up to date on every load.
But because a new request triggers a new render, SSR requires more server resources and is consequently slower to load.

ISR offers a middle ground between SSG and SSR.
With ISR, pages are:

- Built at build time and served statically for fast performance
- Regenerated in the background after a configured interval without a full site rebuild

It's performant, but somewhat flexible enough to keep contents up to date.

## 4. Implementation

Implementing ISR in a pages router Next.js project is quite straightforward:
you simply specify a `revalidate` value in your `getStaticProps` function.

I implemented ISR on my project's invitation page with a 24 hour revalidation interval.
Here's a simplified version of my actual implementation as an example.

```tsx
// /src/pages/invitation/[alias]/index.tsx

export default function InvitationPage({ invitation }: InvitationPageProps) {
  return <Invitation invitation={invitation} />;
}

export const getStaticProps: GetStaticProps = async (context) => {
  const alias = context.params.alias.toString() || "";

  try {
    const invitation = await getInvitationByAlias(alias);

    return {
      props: {
        invitation,
      },
      revalidate: ONE_DAY,
    };
  } catch (error) {
    return {
      props: {
        invitation: null,
      },
      revalidate: 1,
    };
  }
};

export const getStaticPaths: GetStaticPaths = async () => {
  return {
    paths: [],
    fallback: true,
  };
};
```

### 4-1. ISR with Dynamic Routes

One important detail to note is that the invitation page uses a dynamic slug in its path: '/invitation/[alias]'.
Since users customize their own invitation aliases, it's impossible to know ahead of build time what every alias will turn out to be.

I mentioned earlier that ISR pages are generated at build time and regularly revalidated.
But in cases like this where the path is dynamic, we can use the `getStaticPaths` function with an empty `paths` array to opt Next.js out of pre-building any pages.

Instead, Next.js will generate each page during runtime when they are first requested for.

### 4-2. Revalidate = 1

When an error occurs while fetching the invitation data,
the `getStaticProps` function throws and falls into the catch block.
In many cases, errors are not permanent and the fix is a simple retry.
Therefore, it's best not to cache error responses for too long.

That's why in the catch block, I set the `revalidate` property to 1.
This tells Next.js to mark the page as stale after just one second.
By doing so, I could keep the page within the ISR flow while giving users the ability to retry getting the correct data.

Keep in mind that setting the `revalidate` property to 0 does not work.
Doing so would disable ISR and make the page behave like a statically generated page.
This means that once an error occurs, the error would be cached indefinitely and the page wouldn't update until the next site deployment.

## 5. On-Demand Revalidation

Let’s return to the example of our imaginary user, User A.
If, on the morning of his wedding day, Users A realizes there’s a typo in the address,
he’d likely want to fix it immediately without waiting 24 hours for the next scheduled page revalidation.

On-demand revalidation is a perfect solution for situations like this.
It allows users to manually trigger a page revalidation, bypassing the regular interval and ensuring that updates are reflected instantly.

## 6. Implementing On-Demand Revalidation

To implement on-demand revalidation in a Next.js pages router project:

1. Create a new API route inside the `/pages/api` directory
2. Inside this route, call `res.revalidate()` with the path of the page you want to update
3. Trigger this API route when a manual revalidation is required

```typescript
async function revalidateInvitation(req: NextApiRequest, res: NextApiResponse) {
  const { alias, secret } = req.body;

  if (!alias || !secret) {
    // ...handle bad request error
  }

  if (secret !== process.env.REVALIDATE_SECRET) {
    // ...handle unauthorized error
  }

  try {
    await res.revalidate(`/invitation/${alias}`);

    return res.status(200).json({
      isRevalidated: true,
    });
  } catch (error) {
    // ...handle revalidation error
  }
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  if (req.method === "POST") {
    return await revalidateInvitation(req, res);
  }

  res.setHeader("Allow", ["POST"]);
  res.status(405).end("Method Not Allowed");
}
```

### 6-1. Security Concerns

Exposing your revalidation API route to the public can be risky.
Without proper security measures, anyone who knows the URL could trigger revalidation and consume your server resources.

To prevent this, I ensure that the API route is triggered only from my backend server.
Additionally, I’ve added a simple security layer to the route to verify that incoming requests are authorized.

The revalidation flow works as follows:

1. A user updates their invitation, sending a PATCH request to the backend server
2. Server updates the database and then makes a POST request to the revalidation API route with `REVALIDATE_SECRET` in the request body
3. Next.js server checks whether the provided secret matches its own `REVALIDATE_SECRET` value
4. If the secrets match, Next.js proceeds to revalidate the corresponding `/invitation/[alias]` page

<div className="relative aspect-square w-full">
  <Image
    src="/assets/on-demand-revalidation-diagram.png"
    alt="Diagram of on-demand revalidation"
    fill
    objectFit="contain"
    className="invert dark:invert-0"
  />
</div>

## 7. Results

Implmenting ISR had two major benefits for my project:

1. Lower server load as traffic spikes no longer triggered a flood of database queries
2. Better client performance as most visitors were served static pages

To better visualize, let's let's assume a total of 150 guests requested for an invitation with the alias of 'cool-invy' over a course of three days.

- <strong>Day 1:</strong> 50 guests
- <strong>Day 2:</strong> 0 guests
- <strong>Day 3:</strong> 100 guests

Here is how ISR would work in this scenario:

- The first visitor of Day 1 triggers the initial generation of `/invitation/cool-invy`
- The next 49 guests of Day 1 receive the cached version of the page
- Although the revalidation period expires on Day 2, regeneration does not occur because no one visits the page
- The first visitor of Day 3 triggers the second generation of the page
- The remaining 99 guests on Day 3 get the newly cached version

This means for three days, my backend server had to only handle 2 requests while the website served 150 visitors.
It also means only 2 of the 150 visitors had to experience a slight delay in page load time, while the remaining 148 visitors were able to see the page near instantly.

And thanks to on-demand revalidation, I was able to enjoy the benefits of ISR without compromising user experience.
Without it, I likely wouldn’t have adopted ISR at all — or at the very least wouldn’t have been so bold in setting a long revalidation interval.

If your project has similar requirements as mine,
or if you’re simply trying to better understand how ISR and on-demand revalidation work,
I highly recommend implementing them yourself.
You may be surprised by how much performance and flexibility they can offer.
