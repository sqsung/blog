---
title: "Using ISR and On-Demand Revalidation to Improve the Performance of My Next.js Project"
summary: "I think I found the perfect use case for ISR and on-demand revalidation."
tags: ["Frontend", "Nextjs", "ISR", "On-Demand-Revalidation"]
createdAt: "2025-06-30"
isPublished: false
---

## 1. My Project

Over the past few months, I've dedicated much of my free time building a web service where young Korean couples can come create/share digital invitations to their weddings.

As with any side project, I learned a lot throughout the process.
But one of the most valuable takeaway for me was gaining a deeper understanding of how ISR (Incremental Static Regeneration) and on-demand revalidation work in a real-world scenario.

To explain how I improved my service's performance by using these techniques,
let's first explore some key usage patterns I observed during the service's beta launch.

### 1-1. Key Usage Patterns

After completing the initial version, I granted free access to a handful of users.
My original goal was simply to confirm everything worked as intended before launching a paid version.
But through this test run, I discovered some interesting user behaviors:

1. Each user shared their invitation with approximately 300 guests on average
2. Sharing typically occurred in bulks. This means users usually shared their invitations to dozens of guests at once
3. Guests usually checked the invitation twice: once immediately after receiving it, and again on the day of the wedding to confirm the event's time and location

### 1-2. Implications

Let's take an imaginary user, User A, as an example.
Eager to have a well-attended wedding, User A invites a total of 500 guests over a span of five consecutive days.
And to simplify the process, he shares his invitation to exactly 100 guests each day.

Based on usage patterns, User A's invitation page would likely experience six distinct traffic spikes.
Over the five days when User A is sending out his invitation, the page would likely receive 100 requests per day.
Then traffic will peak on the wedding day as around 500 guests revisit the page to confirm event details.

If the invitation page was rendered using SSR or CSR, each of these requests would trigger a unique call to fetch the invitation data.
This would put an excessive load on my little precious t3-micro EC2 instance server.
And since invitation data rarely changes, this excessive load is by all means avoidable.

### 1-3. Next.js Version

For context, I used Next.js version 14.2.3 (page router) to build my project.
Keep in mind that things discussed within this post may not be applicable to future versions of Next.js.

```JSON
"next": "14.2.3",
```

## 2. Incremental Static Regeneration

Next.js offers the following server-side rendering strategies:

1. Static Site Generation (SSG)
2. Server-Side Rendering (SSR)
3. Incremental Static Regeneration (ISR)

SSG builds pages during deployment and serves them as static HTML.
This keeps pages fast and efficient, but any content updates require a full rebuild and redeployment.
As a result, SSG is best suited for pages where the data changes infrequently and real-time updates are not critical to the user experience.

On the other hand, SSR renders pages on every new request.
It's ideal for pages with frequently changing data that needs to be up to date on every load.
But because a new request triggers a new render, SSR requires more server resources and is consequently slower to load.

ISR offers a middle ground between SSG and SSR.
With ISR, pages are:

- Built at build time and served statically for fast performance
- Regenerated in the background after a configured interval without a full site rebuild

It's performant, but somewhat flexible enough to keep contents up to date.

I implemented ISR on the invitation page with a 24 hour revalidation interval.
This turned out to be an ideal solution for reducing unnecessary load on the server while improving page performance because
invitation details rarely changed once sharing begins and page traffic is typically concentrated within the 24 hour time frame.

Implementing ISR in a page router Next.js project is quite straightforward:
you simply specify a `revalidate` value in your `getStaticProps` function.

Here's a simplified version of my actual implementation as an example.

```tsx
export default function InvitationPage({ invitation }: InvitationPageProps) {
  return <Invitation invitation={invitation} />;
}

export const getStaticProps: GetStaticProps = async (context) => {
  const alias = context.params.alias.toString() || "";

  try {
    const invitation = await getInvitationByAlias(alias);

    return {
      props: {
        invitation,
      },
      revalidate: ONE_DAY,
    };
  } catch (error) {
    return {
      props: {
        invitation: null,
      },
      revalidate: 1,
    };
  }
};

export const getStaticPaths: GetStaticPaths = async () => {
  return {
    paths: [],
    fallback: true,
  };
};
```

One important detail to note is that the invitation page uses a dynamic slug in its path ('/invitation/[alias]').
Since users are responsible for customizing their invitation aliases, it's impossible to know any exact paths ahead of build time.

I mentioned earlier that ISR pages are generated at build time and revalidated after a set interval.
But in the cases like this, pre-building all possible pages during build time is obviously impossible.

To handle this, I used `getStaticPaths` function with an empty paths array.
This tells Next.js not to pre-render any pages at build time, and instead, generate each page on-demand when itâ€™s first requested for.

So let's say a total of 150 guests visited the invitation page with the alias 'cool-invy' over a course of three days.

- <strong>Day 1:</strong> 50 guests
- <strong>Day 2:</strong> 0 guests
- <strong>Day 3:</strong> 100 guests

Here is how ISR would work in this scenario:

- The first visitor of Day 1 triggers the initial generation of `/invitation/cool-invy`
- The next 49 guests of Day 1 receive the cached version of the page
- Although the revalidation period expires on Day 2, regeneration does not occur because no one visits the page
- The first visitor of Day 3 triggers the second generation of the page
- The remaining 99 guests on Day 3 get the newly cached version

## 3. On-Demand Revalidation

In most cases, there probably is a reason why the developer chose to use ISR instead of SSG (Static Site Generation) for certain pages.
In many cases, the reason is because the data used in the page is definitely not static and may need to be updated quickly.
